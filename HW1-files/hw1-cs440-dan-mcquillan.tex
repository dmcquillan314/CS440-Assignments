\input{cs440_style.tex}
\usepackage{algorithm}
\usepackage{listings}
%\usepackage{algpseudocode}
\usepackage{graphicx,amssymb,amsmath}
\usepackage{epstopdf}
\usepackage{amsfonts}
\sloppy


\oddsidemargin 0in
\evensidemargin 0in
\textwidth 6.5in
\topmargin -0.5in
\textheight 9.0in

\begin{document}

\solution{Dan McQuillan}{\today}{1}{Spring 2014}

\pagestyle{myheadings}  % Leave this command alone

\begin{enumerate}

	\item {\bf Solution to problem 1}
	
	\begin{enumerate}
	
		\item[(a)] 
			\begin{enumerate}
			\item[(i)] depth-first \\
				\begin{tabular}{c|l}
					\bf{n} & \bf{q} \\
					\hline
					- & \((A)\) \\
					A & \((B,C,D)\) \\
					B & \((E,F,C,D)\) \\
					E & \((K,F,C,D)\) \\
					K & \((F,C,D)\) \\
				\end{tabular}
			\item[(ii)] breadth-first \\
				\begin{tabular}{c|l}
					\bf{n} & \bf{q} \\
					\hline 
					- & \((A)\) \\
					A & \((B,C,D)\) \\
					B & \((C,D,E,F)\) \\
					C & \((D,E,F,G,H)\) \\
					D & \((E,F,G,H,I,J)\) \\
					E & \((F,G,H,I,J,K)\) \\
					F & \((G,H,I,J,K,L)\) \\				
					G & \((H,I,J,K,L)\) \\				
				\end{tabular}
			\item[(iii)] uniform-cost \\
				\begin{tabular}{c|l}
					\bf{n} & \bf{q} \\
					\hline 
					- & \((A)\) \\
					A & \((B,C,D)\) \\
					B & \((C,E,F,D)\) \\
					C & \((E,F,H,D,G)\) \\
					E & \((F,H,D,G,K)\) \\
					F & \((H,L,D,G,K)\) \\
					H & \((L,D,N,G,M,K)\) \\
					L & \((D,N,G,M,K)\) \\
					D & \((N,G,M,I,K,J)\) \\
					N & \((G,M,I,K,J)\) \\				
				\end{tabular}
			\item[(iv)] greedy/best-first \\
				\begin{tabular}{c|l}
					\bf{n} & \bf{q} \\
					\hline 
					- & \((A)\) \\
					A & \((C,D,B)\) \\
					C & \((G,H,D,B)\) \\
					G & \((H,D,B)\) \\			
				\end{tabular}
			\item[(v)] $A^*$ \\
				\begin{tabular}{c|l}
					\bf{n} & \bf{q} \\
					\hline 
					- & \((A)\) \\
					A & \((C,B,D)\) \\
					C & \((B,H,D,G)\) \\
					B & \((H,D,G,E,F)\) \\
					H & \((D,G,N,E,F,M)\) \\
					D & \((G,N,E,F,I,J,M)\) \\
					G & \((N,E,F,I,J,M)\) \\			
				\end{tabular}
			\end{enumerate}
		\item[(b)] 
			\begin{enumerate}
				\item[(i)] Depth first is not admissible since it does not take weights or distance into consideration and could easily not choose the cheapest goal. \\
				\item[(ii)] Breadth first search is not admissible for the same reason as depth first search since it does not consider weights or distance when finding a goal state. \\
				\item[(iii)] Uniform cost search is admissible since it is using the actual cost to the node and recalculates and sorts the order of the queue based upon the total cost from the root node. \\
				\item[(iv)] Greedy / Best-First search is not admissible since it does not take the cost of getting from \( n \rightarrow n^{\prime} \) into consideration and it only depends on how close the node is estimated to be from the goal. \\
				\item[(v)] \(A^*\) search is admissible because when it terminates its search, it has found a path whose cost is lower than the estimated cost of any path through any open node. Although, since those estimates are optimistic, \(A^*\) can safely ignore those nodes.  Therefore, \(A^*\) will never overlook the possibility of a lower cost and is admissible. \\
			\end{enumerate}
			\item[(c)] We know that for all heuristic functions, it is consistent if for every node n and every successor \(n^{\prime} \) of n  generated by any action a, the estimated cost of reaching the goal from n is no greater than the step cost of getting to \(n^{\prime} \) plus the estimated cost of reaching the goal from \(n^{\prime} \).  Or more formally: 
			
			\[ 
				h(n) \le c(n,a,n^\prime) + h(n^\prime) 
			\]
			
			\textbf{Suppose:}  \\
			B is an unreachable node and therefore the cost from any node, \(n \in nodes\), the cost will be infinite.
			
			\textbf{Then:} \\
			\[ h(n) \le c(n,a,B) + h(B) \]
			h(B) must therefore also be infinite since it is an unreachable and infinitely far away from any goal node \\
			
			\(\therefore h(n) \le \infty + \infty \) \\
			\hspace*{3 mm} \( h(n) \le \infty \rightarrow  \)  the heuristic is consistent
		\end{enumerate}
			
 	\item {\bf Solution to problem 2}
	
		\begin{enumerate}
			\item[(a)]
				\begin{enumerate}
					\item[(i)] A data structure to represent this structure could be a Tuple. Each state would be a tuple3, where it would contain three slots which would be filled with an enum value where the enumeration is as follows:\\
					
						StateAttributeType \{ \\
						\hspace*{4mm} Empty, \\
						\hspace*{4mm} Box, \\
						\hspace*{4mm} Agent, \\ 
						\hspace*{4mm} Agent\_With\_Box \\
						\} \\
						
						A goal state for this data structure would be defined as the following tuple3: \\
					
						Tuple3 \{ \\
						\hspace*{4mm} StateAttributeType.Box, \\
						\hspace*{4mm} StateAttributeType.Box, \\
						\hspace*{4mm} StateAttributeType.Agent \\
						\} \\
						
					\item[(ii)] Pickup and Drop Preconditions and Effects
					\begin{enumerate}
						\item[\bf Pickup Operator] 
							preconditions:
							\begin{itemize}
								\item{Agent must not be holding a box}
								\item{Agent must be in a square with a box}
							\end{itemize}
							effects:
							\begin{itemize}
								\item{Agent now has a box.}
								\item{Box is removed from square}
							\end{itemize}
						\item[\bf Drop Operator]
							preconditions:
							\begin{itemize}
								\item{Agent must be holding a box}
							\end{itemize}
							effects:
							\begin{itemize}
								\item{Box replaces empty state}
								\item{Agent state replaces agent with box state}
							\end{itemize}
					\end{enumerate}
					
				\end{enumerate}
			\item[(b)]
				\begin{enumerate}
					\item[(i)] 38 nodes must be visited at minimum for breadth first to find a goal.  It is guaranteed to find a goal state since it will expand every level of the tree.  However, an optimal solution would not be found since the cost of going from state to state is not considered.  This is because breadth first is not an admissible search algorithm.
					
					\item[(ii)] The fewest number of nodes that will be visited is 5 nodes. The search is not always guaranteed to reach the goal since the algorithm is not admissible and could for example end up stuck in a infinite depth caused by the switching between two states.  For the same reason as Breadth first search an optimal solution would not be found.
					
					\item[(iii)]  The fewest number of nodes that will be visited is 6 nodes.  We know that the uniform cost search is admissible and by definition would reach a goal state of which is optimal.
					
				\end{enumerate}
		\end{enumerate}

\end{enumerate}



\end{document}

